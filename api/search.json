[{"id":"cc267b1dfcd7d2b23d2458ee30dfed69","title":"空域图像增强技术","content":"背景，直方图，算术逻辑操作，平滑滤波器，锐化滤波器，混合空间增强，图像素描效果\n\n\n\n[TOC]\n背景知识定义（What）\n\n\n\n\n\n\n\n\n图像增强：突出一幅图像中的某些信息，同时，削弱或去除某些不需要的信息的方法。\n目的（Why）改善图像的视觉效果，或者将图像转换成一种更适合人或机器进行分析处理的形式。图像增强并不以图像保真为准则，而是突出有意义的信息，抑制无用信息，提高图像使用价值。\n方法（How）空间域处理\n全局运算：在整个图像空间域进行\n局部运算：在像素有关的空间域进行\n点运算：对图像作逐点运算\n\n频域处理\n在图像的Fourier变换域上进行处理\n\n空域图像增强基础空域图像增强的一般数学表达式：$$g(x, y) = T[f(x, y)]$$\n算子T在操作(x, y)的某个邻域上（掩码处理/滤波）\n\n基本的灰度变换（点处理）当领域为1X1，此时T成为灰度级变换函数，此时处理成为点处理。s为输出灰度级，r为输入灰度级。$$s = T(r)$$两个常用的灰度级变换函数：对照度拉伸和阈值函数\n\n\n一般查表获得映射关系。\n负（反转）变换$$s = T(r) = L - 1 -r$$\n如图图像的灰度范围为[0, L-1]\n\n对数变换$$s = c\\log(1 + r), r \\geq 0$$\n对数变换可以扩散低灰度级范围，压缩高灰度级范围。\n\n幂率变换$$s = C r^{\\gamma}  \\quad C,\\gamma &gt; 0$$\n当c = 1时\n\n幂率变换可以用于输入图像的r校正。数字图像信息的获取来自CCD图像传感器。但是CCD的输入输出特性不是线性的，所以需要进行校正处理，也叫伽马校正。\n设CCD的输入（入射光强度）为r，输出（电流前端）为s，则$$s = Cr^{\\gamma}$$所以需要进行逆变换进行校正。下图是效果示意。\n\n伽马校正被广泛使用在图像捕捉、打印和显示设备上。\n幂率变换也可以用来压缩亮或暗的灰度级。\n\n线性变换线性灰度变换在图像对比度不足，使得细节分辨不清使可以将灰度范围线性扩展。\n\n分段线性灰度变换将感兴趣的灰度范围线性扩展，相对抑制不感兴趣的灰度区域。\n\n\n灰度切割用于突出某个特定的灰度范围，从而增强某个专门的特征。如卫星图像的水团。\n\n位平面切割位平面切割把数字图像分解成位平面的组合。可以在图像量化时帮助决定使用的位数是否足够，在图像压缩中也有用。\n\n从图上可以看到，前四位包含类视觉上的重要信息。其他位包含较多细节信息。\n灰度直方图定义灰度图上一个二维图，横坐标表示灰度级，纵坐标表示出现次数（像素个数）。\n\n\n\n性质直方图描述了每个灰度级具有的像素的个数，反映的是图像灰度的统计信息，但丢失了所有这些像素点的空间信息，即像素点的相对位置。因此，任一特定的图像有唯一的直方图，但反之并不成立。\n归一化灰度直方图可以得到图像的概率密度函数（PDF）。\n通过直方图可以反映图像的总体性质。\n\n直方图可以用于数字化参数的选择和边界阈值的选取。\n\n\n色彩直方图色彩直方图是高维直方图的特例，它统计色彩的出现频率，即色彩的概率分布信息。一般不直接在RGB色彩空间中统计，而是在将亮度分离出来后，对代表色彩部分的信息进行统计，如在HSI空间的HS子空间、YUV空间的UV子空间，以及其它反映人类视觉特点的彩色空间表示中进行。\n直方图均衡处理直方图均衡化(Histogram Equalization)是一种增强图像对比度(Image Contrast)的方法，其主要思想是将一副图像的直方图分布变成近似均匀分布，从而增强图像的对比度。$$假设有图像A，其直方图分布H_A(D)，D是灰度。\\现在我们向利用一个单调非线性映射f:R-&gt;R 进行点处理，将图像A变为B，\\即对A图像的每个像素点施加f变换$$\n局部增强代数和逻辑运算空间锐化滤波器加强图像的边缘或轮廓，或者提取边缘。\n各向同性的边缘检测算子，对任意边缘轮廓有相同的检测能力。\n","slug":"空域图像增强技术","date":"2022-11-23T02:37:43.000Z","categories_index":"课程","tags_index":"图形图像处理","author_index":"YiLongDong"},{"id":"234ab57484087ede9a8769f2eb7c371f","title":"1数字图像处理-基础","content":"\n\n\n人眼视觉要素：\n视网膜的感光细胞：\n​\t杆状细胞：单色弱光\n​\t锥状细胞：彩色强光\n色彩模型：\nRGB模型\nHIS模型 H: hue色相 S: saturation 饱和度 I: intensity 强度，明度\n\nYUV模型\nYCbCr模型\n空间离散：采样\n幅值离散：量化\n二值图像，黑白图像，每个像素1bit\n二值图像可以用特殊的表示方法，比如链码(Freeman码)，可以用来表示直线或曲线组成的二值图像，描述边界轮廓。可以达到相当高的压缩效率。\n\n图像文件存储格式：\nBMP格式，基本上一般是一种非压缩图像格式\nJPEG文件格式，静止图像压缩，有损编码方式，是一种变换编码，对高低频信号区别对待。\nGIF文件格式，采用复杂的LZW编码方式，一个GIF文件可以存储多幅图像，支持图像定序显示。\nTIFF文件格式，是光栅图像文件格式，可能来源有扫描仪，CAD系统，地理信息等。\n图像像素间的基本关系\n\n像素邻域（neibors）4邻域，8邻域\n\n\n","slug":"1数字图像处理-基础","date":"2022-11-21T11:13:42.000Z","categories_index":"笔记","tags_index":"OpenGL,ffmpeg","author_index":"YiLongDong"},{"id":"fd56f016e0cd406f4c293dabe662e43f","title":"1数字图像处理-绪论","content":"点击阅读前文前, 首页能看到的文章的简短描述\n\n\n\n","slug":"1数字图像处理-绪论","date":"2022-11-21T11:07:31.000Z","categories_index":"课程","tags_index":"数字图像处理","author_index":"YiLongDong"},{"id":"834aeb9ffdd87c27317f1a38c3063e2c","title":"Java Basics","content":"The Java Programming Language and the Java Platform\n\n\nhttps://www.oracle.com/topics/technologies/newtojava/programming-center.html\nJava 平台的两个主要组件是 Java 应用程序编程接口 (API)和将 Java 代码解释为机器语言的 Java 虚拟机 (JVM)。\n\nAPI和JVM使得程序独立于硬件\n\n\nLearn about the JVM and the APIs\n\nLearn Java programming with The Java Tutorials, a comprehensive source for Java language concepts. Object-oriented and Java programming are explained with graphics and code examples.\nThe Young Developers page summarizes the tools and learning resources for each software tool.\nRecommended books:\n\n“Core Java, Volume I - Fundamentals (9th edition) by Cay Horstmann and Gary Cornell\n“Core Java, Volume II – Advanced Features (9th edition) by Cay Horstmann and Gary Cornell\n“Head first Java” by Kathy Sierra and Bert Bates\n“Thinking in Java” by Bruce EckelOracle Java Magazine book section\n\n\n","slug":"Java-Basics","date":"2022-11-15T03:13:16.000Z","categories_index":"笔记","tags_index":"Java","author_index":"YiLongDong"},{"id":"e7d1a735cee263f418cd0521b289ed0f","title":"设计模式-组件协作","content":"点击阅读前文前, 首页能看到的文章的简短描述\n\n\n\n","slug":"设计模式-组件协作","date":"2022-11-13T11:51:07.000Z","categories_index":"笔记","tags_index":"OpenGL,ffmpeg","author_index":"YiLongDong"},{"id":"d44ddd92909205d9b5ecdd44a8d6d7b5","title":"银发经济的黄金期--社会经济如何迎接老龄化时代的到来","content":"点击阅读前文前, 首页能看到的文章的简短描述\n\n\n\n","slug":"银发经济的黄金期-社会经济如何迎接老龄化时代的到来","date":"2022-11-12T11:32:09.000Z","categories_index":"笔记","tags_index":"老龄化","author_index":"YiLongDong"},{"id":"6904b6e2cd4631c9cbc3edadb24f9469","title":"rust安装","content":"点击阅读前文前, 首页能看到的文章的简短描述\n\n\n\n","slug":"rust安装","date":"2022-11-09T03:05:56.000Z","categories_index":"笔记","tags_index":"OpenGL,ffmpeg","author_index":"YiLongDong"},{"id":"5c48409009b67d9a464e12ac8db87536","title":"2.3 cmake主要语法 属性与变量","content":"点击阅读前文前, 首页能看到的文章的简短描述\n\n\n\n属性与变量属性与变量的区别属性是作用域为目标(target)的变量，但是也有全局属性。全局属性是一个没有缓存的全局变量。\n属性语法set_propertyset_property(&lt;GLOBAL|\n\tDIRECTORY [&lt;dir&gt;]|\n\tTARGET [&lt;target&gt; ...] |\n\tSOURCE [&lt;src1&gt; ...]\n\t\t[DIRECTORY &lt;dirs&gt; ...] |\n\t\t[TARGET_DIRECTORY &lt;targets&gt; ...] |\n\tINSTALL [&lt;file&gt; ...] |\n\tTEST [&lt;test&gt; ...] |\n\tCACHE [&lt;entry&gt; ...] &gt;\n\t[APPEND] [APPEND_STRING]\n\tPROPERTY &lt;name&gt; [&lt;value&gt; ...])\n\nget_propertydefine_property属性分类打印属性cmake预置属性","slug":"2-3-cmake主要语法-属性与变量","date":"2022-11-08T03:36:06.000Z","categories_index":"笔记","tags_index":"cmake","author_index":"YiLongDong"},{"id":"c49836dd2f2f092644c9e09818c7b43e","title":"cmake系统学习:2.2 cmake主要语法 变量与缓存","content":"点击阅读前文前, 首页能看到的文章的简短描述\n\n\n\n变量与缓存缓存变量基本语法写到缓存文件里了\n只要缓存文件里有了就跳过，想要修改需要加FORCE\nset(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])\ntype:\nBOOL  ON/OFF选择框\nFILEPATH 文件选择\nPATH 目录选择\nSTRING 字符串\nINTERNAL 内部变量，内部的全局缓存变量，不会开放给用户使用\nFORCE强制修改，不加的话第一次设置后，第二次设置不会设置\n缓存变量作用域普通变量的作用域是自身和子模块(add_subdirectory或include)\n缓存变量的作用域是全局的\nccmakeccmake是在cmake生成之后，对cmake的cache进行修改，重新生成makefile文件。所以需要先执行cmake。\nCACHE覆盖策略设置缓存变量和普通变量重名时覆盖策略\ncmake_policy(SET CMP0126 &lt;NEW|OLD&gt;)\n# NEW 不删除重名普通变量\n# OLD 删去重名的普通变量\n\n访问cahce变量\n${NVAR} 先找普通变量，再找cache变量。重名时默认是会删掉普通变量\n$CACHE{NVAR}直接找cache变量\nCMake内置缓存变量-D传递缓存变量在cmake生成前传递的变量都是缓存变量\n","slug":"cmake系统学习-2-2-cmake主要语法-变量与缓存","date":"2022-11-08T03:02:24.000Z","categories_index":"笔记","tags_index":"make","author_index":"YiLongDong"},{"id":"a5750675f9146468dc57ef3297b265da","title":"cmake系统学习:2.1 cmake主要语法","content":"if流程控制\n\n\nif()\nelseif()\nelse()\n\t\nendif()\n\nif 真假值if(&lt;constant&gt;)\n0,OFF,NO,FALSE,N,IGNORE,NOTFOUND,空字符串,以-NOTFOUND结尾的字符串则为假\n未定义变量为空字符串\n环境变量总为假\nif(&lt;variable&gt;)\n环境变量总为假（if不支持的都是假的）\n宏参数不是变量，宏是个替换\nif(&lt;string&gt;)\n字符串的值是常量真则为真，例如\"YES\"\n其他带引号的字符串都是假\nIf逻辑操作符NOT AND OR + ()\nif判断语句一元判断EXISTS 判断是否存在\nCOMMAND 判断后面是不是cmake命令\n DEFINED 变量是否定义\nif(DEFINED &lt;name&gt;|CACHE{&lt;NAME&gt;}|ENV{&lt;name&gt;})\n判断是否定义了给定的变量/缓存变量/环境变量\n\n\n\n二元判断EQUAL,LESS,LESS_EQUAL,GREATER,GREATER_EQUAL(只能判断数字)\nSTREQUAL,STRLESS,STRLESS_EQUAL,STRGREATER,STRGREATER_EQUAL(也可以判断数字)\nVERSION_EQUAL,VERSION_LESS,VERSION_LESS_EQUAL,VERSION_GREATER,VERSION_GREATER_EQUAL\nIN_LIST\n if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;)\nMATCHES 支持正则\nif(&lt;variable|string&gt; MATCHES regex)\nif (\"abcd1234\" MATCHES \"^[a-z]+$\")\n\tmessage(\"match\")\nelse()\n\tmessage(\"not match\")\nendif()\n#[[\n^意思是开头\n$意思是结尾\n+一到多个\n]]\n\n表达式语句","slug":"cmake系统学习-2-1-cmake主要语法","date":"2022-11-07T13:24:57.000Z","categories_index":"笔记","tags_index":"OpenGL,ffmpeg","author_index":"YiLongDong"},{"id":"9f2413725e1494f52893c05d29ad7cbd","title":"cmake系统学习:2 常用功能","content":"\n\n\ncmake常用功能自动导入源文件和头文件\naux_source_directory\n\naux_source_directory(\"./src\" SRCS)\n把./src路径下所有文件存入SRCS变量中\n\nfile\n\nfile(GLOB H_FILE \"${INCLUDE_PATH}/xx/*.h*\")\nfile(GLOB H_FILE_I \"${INCLUDE_PATH}/*.h\")\ncmake分步编译\n选择编译目标\ncmake --build . --target help\n\n预处理\ncmake --build . --target xx.i\n\n编译\ncmake --build . --target xx.s\n\n汇编\ncmake --build . --target xx.o\n\n链接\n\n运行\n动态库加载路径\n\n清理\ncmake --build . --target clean\n\n\n打印具体指令CMAKE_VERBOSE_MAKEFILE\ncmake --build . -v\n显示详细的生成日志，默认是OFF\nset(CMAKE_VERBOSE_MAKEFILE ON)\n或者\ncmake --build . --verbose\n设置输出目录\n库输出路径\nCMAKE_LIBRARY_OUTPUT_DIRECTORY\n\n归档输出路径\nCMAKE_ARCHIVE_OUTPUT_DIRECTORY\n\n执行程序输出路径\nCMAKE_RUNTIME_OUTPUT_DIRECTORY (bin)\n\n\n\n","slug":"cmake系统学习-2-常用功能","date":"2022-11-07T12:41:22.000Z","categories_index":"笔记","tags_index":"cmake","author_index":"YiLongDong"},{"id":"b8d7042e48b8c930a1e0538bec9f2d5d","title":"cmake系统学习:1 注释,message,set,include","content":"cmake基础\n\n\n\n注释,message, set, include注释\n行注释\n\n# 注释\n\n\n括号注释(3.0之后)\n\n#[[第一行注释\n第二行注释]]\nmessage(\"arg1\\n\" #[[注释内容]] \"arg2\")\n\n\n\nmessagemessage日志级别message(arg1 arg2 arg3)\nmessage([&lt;mode&gt;] \"message text\" ...)\n\n# mode\n#[[\nFATAL_ERROR 停止cmake运行和生成\nSEND_ERROR cmake继续运行，生成跳过\nWARNING 打印到stderr 会打印路径和行数\n(none) or NOTICE 打印到stderr\nSTATUS 项目用户可能感兴趣的信息，会加前缀--\nVERVOSE 针对项目用户的详细信息，会加前缀--，默认不显示\nDEBUG 开发人员使用的信息\nTRACE 非常低级实现细节的消息\n]]\n\n\ncmake -S . -B build --log-level=VERBOSE\n\nmessage report checks插座库日志message(&lt;checkState&gt; \"msg\" ...)\n# 可以嵌套\n# checkState\n#[[\nCHECK_START\nCHECK_PASS\nCHECK_FAIL\n]]\n\n\n\n\n\n\nmessage(CHECK_START \"find xxx\")\n# 增加缩进\nset(CMAKE_MESSAGE_INDENT \"--\")\n\n# 嵌套 1\nmessage(CHECK_START \"find yyy\")\nmessage(CHECK_PASS \"found\")\n# 嵌套 2\nmessage(CHECK_START \"find zzz\")\nmessage(CHECK_FAIL \"not found\")\n\n# 取消缩进\nset(CMAKE_MESSAGE_INDENT \"\")\nmessage(CHECK_FAIL \"not found\")\n\n变量变量未设置返回空字符串, ${name}\n变量引用可以嵌套，并由内而外求值${prefix${name}}\n变量名大小写敏感\nset(), unset()\nset(VAR1 \"VAR1_value\")\nmessage(\"\\${VAR1}=${VAR1}\")\nmessage(\"\\${VAR1}=${VAR1}\")\n\ncmake内建变量提供信息的变量\nPROJECT_NAME 项目名\n\n改变行为的变量\nBUILD_SHARED_LIBS\n\n描述系统的变量控制构建过程的变量CMAKE_COLOR_MAKEFILE,默认ON\ncmake传递变量给C++\nCLI\ncmake .. -Dxx=yy -Dzz\n\ncmake\nadd_definitions(-Dxx=yy -Dzz)\nzz默认值为1\n\n\ninclude make模块include(\"cmake/test.cmake\")\n\ninclude(\"cmake/xx.cmake\" OPTIONAL) # 可选，文件不存在不报错\n\ninclude(\"cmake/xx.cmake\" OPTIONAL RESULT_VARIABLE ret) # 获得是否找到的返回值\nmessage(\"RESULT_VARIABLE ret = ${ret}\") # ret = NOFOUND\n\ninclude(\"cmake/test.cmake\" OPTIONAL RESULT_VARIABLE ret) # 获得是否找到的返回值\nmessage(\"RESULT_VARIABLE ret = ${ret}\") #ret = 导入的cmake文件路径\n\n\n\n","slug":"cmake系统学习-1-注释与message和set","date":"2022-11-07T11:26:22.000Z","categories_index":"笔记","tags_index":"cmake","author_index":"YiLongDong"},{"id":"a428701588e00e4dd38a37db22dfe9f5","title":"音视频很好的链接","content":"点击阅读前文前, 首页能看到的文章的简短描述\n\n\n\nhttp://jhuster.com 卢俊\nhttps://blog.51cto.com/ticktick/1956269 音视频入坑指南\nhttps://zhuanlan.zhihu.com/p/51371354 播放器架构\n","slug":"音视频很好的链接","date":"2022-11-05T15:41:47.000Z","categories_index":"笔记","tags_index":"OpenGL,ffmpeg","author_index":"YiLongDong"},{"id":"4ba2934548c823e4c39b3ff3e4179b40","title":"git rebase使用","content":"git rebase法则：永远不要在公共分支上使用它。\n\n\n\n\n\n合并主干提交到featuregit checkout feature\ngit merge master\n# git merge feature master\n# 这样会在feature创建一个merge commit\n\n\ngit checkout feature\ngit rebase master\n# git rebase -i master\n# 与merge提交不同，rebase通过为原始分支中每个提交创建全新的commits来重写项目历史记录\n\n\n要使用交互式 rebase，需要使用 git rebase 和 -i 选项：\ngit checkout feature\ngit rebase -i master\n\n这将打开一个文本编辑器，列出即将移动的所有提交：\npick 33d5b7a Message for commit #1\npick 9480b3d Message for commit #2\npick 5c67e61 Message for commit #3\n\n此列表准确定义了执行 rebase 后分支的外观。通过更改 pick 命令或重新排序条目，你可以使分支的历史记录看起来像你想要的任何内容。例如，如果第二次提交 fix 了第一次提交中的一个小问题，您可以使用以下 fixup 命令将它们浓缩为一个提交：\npick 33d5b7a Message for commit #1\nfixup 9480b3d Message for commit #2\npick 5c67e61 Message for commit #3\n\n\n本地清理git checkout feature\ngit rebase -i HEAD~3\n\n\n如果要使用此方法重写整个功能，git merge-base 命令可用于查找 feature 分支的原始 base。以下内容返回原始 base 的提交ID，然后你可以将其传递给 git rebase：\ngit merge-base feature master\n\n","slug":"git-rebase使用","date":"2022-11-03T14:10:26.000Z","categories_index":"笔记","tags_index":"git","author_index":"YiLongDong"},{"id":"488532bb3413d4814952662362babd82","title":"git commit规范","content":"点击阅读前文前, 首页能看到的文章的简短描述\n\n\n\nhttp://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\nCommit message 都包括三个部分：Header，Body 和 Footer。\n&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n// 空一行\n&lt;body&gt;\n// 空一行\n&lt;footer&gt;\n\nHeaderHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。\n（1）type\n\n\n\n\n\n\n\n\n\nfeat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动\n（2）scope\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n（3）subject\nsubject是 commit 目的的简短描述，不超过50个字符。\n\n\n\n\n\n\n\n\n\n\n以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n第一个字母小写\n结尾不加句号（.）\n\nBodyMore detailed explanatory text, if necessary.  Wrap it to \nabout 72 characters or so. \n\nFurther paragraphs come after blank lines.\n\n- Bullet points are okay, too\n- Use a hanging indent\n\n\n\nFooter\n关闭Issue\n# 关闭单个\nCloses #234 \n# 关闭多个\nCloses #123, #245, #992\n\n\n\n不兼容变动\n\n\n感觉基本不用，用到看原文\nRevert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。\nrevert: feat(pencil): add 'graphiteWidth' option\n\nThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\n\nBody部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。\n如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。\n工具CommitizenCommitizen是一个撰写合格 Commit message 的工具。\n# 安装时遇到报错可以换淘宝源\n# npm config set registry https://registry.npm.taobao.org\nnpm install -g commitizen\n\n在项目路径下运行\ncommitizen init cz-conventional-changelog --save --save-exact\n\n以后，凡是用到git commit命令，一律改为使用git cz。\n如果要编写多行，使用\\n 换行。回车直接结束描述\n\nstandard-changelog根据commit生成changelog\nnpm install -g standard-changelog\ncd project_dir\nstandard-changelog\n# npm install -g conventional-changelog\n# cd my-project\n# conventional-changelog -p angular -i CHANGELOG.md -w\n\n\n\n修改git commit信息1、将当前分支无关的工作状态进行暂存\ngit stash\n\n2、将 HEAD 移动到需要修改的 commit 上\ngit rebase 9633cf0919^ --interactive\n\n3、找到需要修改的 commit ,将首行的 pick 改成 edit4、开始着手解决你的 bug5、 git add 将改动文件添加到暂存6、 git commit –amend 追加改动到提交7、git rebase –continue 移动 HEAD 回最新的 commit8、恢复之前的工作状态\ngit stash pop\n","slug":"git-commit规范","date":"2022-11-03T13:12:55.000Z","categories_index":"笔记","tags_index":"git","author_index":"YiLongDong"},{"id":"7a6e3dad18aab366d395a680cdf73288","title":"git worktree使用","content":"使用git worktree同时在多个 branch 上工作。\n\n\n\n参考一些文章\n\ngit worktree add [-f] [--detach] [--checkout] [--lock [--reason &lt;string&gt;]] [-b &lt;new-branch&gt;] &lt;path&gt; [&lt;commit-ish&gt;]\ngit worktree list [-v | --porcelain [-z]]\ngit worktree lock [--reason &lt;string&gt;] &lt;worktree&gt;\ngit worktree move &lt;worktree&gt; &lt;new-path&gt;\ngit worktree prune [-n] [-v] [--expire &lt;expire&gt;]\ngit worktree remove [-f] &lt;worktree&gt;\ngit worktree repair [&lt;path&gt;...]\ngit worktree unlock &lt;worktree&gt;\n\n使用git worktree可以仅需维护一个 repo，又可以同时在多个 branch 上工作，互不影响。免去分支切换的苦恼。\n git worktree add -b \"feature/feature1\" ../feature/feature1\n # 查看链接工作区下.git\n cat .git\n# gitdir: /Users/dongyilong/test/git_test/demo-project/.git/worktrees/feature1\n\n\ngit worktree list --porcelain\n\n\ngit worktree move \"feature/feature1\" ../feature/feature2\n# 不能移动主工作树或者包含子模块的工作树\n# 工作树的名字为demo-project， feature/feature2\n# git worktree list --porcelain\nworktree /Users/dongyilong/test/git_test/demo-project\nHEAD e1da10447082e472ad8a2b57808d4ef9cec87823\nbranch refs/heads/master\n\nworktree /Users/dongyilong/test/git_test/feature/feature2\nHEAD e1da10447082e472ad8a2b57808d4ef9cec87823\nbranch refs/heads/feature/feature1\n\n\ngit worktree remove feature/feature2\ngit worktree remove -f feature/feature2\ngit worktree prune # 清除$GIT_DIR/worktrees中的工作树信息。\n\n","slug":"git-worktree使用","date":"2022-11-03T08:24:51.000Z","categories_index":"笔记","tags_index":"git","author_index":"YiLongDong"},{"id":"58a6ef8684392e221fda2f90c80f6f4d","title":"clang 编译链接","content":"clang编译与搜索路径\n\n\n\n如果在mac上自己编译了clang,llvm然后安装了，可能会出现找不到文件的错误。\n可以在~/.zshrc中加入\nalias clang++='clang++ -isysroot `xcrun --show-sdk-path` '\nalias clang='clang -isysroot `xcrun --show-sdk-path` '\n\n\n\n\n\nxx.c # 源文件\nxx.i # 预处理后文件\nxx.s # 汇编代码\nxx.o # 目标文件，引用的其他文件的函数地址尚未定义\nxx.out # 可执行文件\n\n编译预处理\nclang -E xx.c # 进行预处理\ncpp xx.c # 编译预处理命令程序是cpp，也可以直接使用cpp进行预处理\nclang -E -c xx.i xx.c # 保存到文件\nclang -o xx.i xx.c # 保存到文件\n\n生成汇编\nclang -S xx.c\nclang -S -o xx.s xx.c\n\n生成.o文件\nclang -c xx.c\n\n保存中间步骤\nclang -save-temps xx.c\n# 会生成xx.i xx.s xx.o a.out\n\n\n\n搜索路径设置#include &lt;xxx&gt; // 只在默认的系统包含路径搜索头文件\n#include \"xxx\" // 现在当前目录搜索头文件\n\n\n\nclang -Ixxx # 增加头文件搜索目录\nclang -include /xxx/xx.h # 增加头文件\nclang -Lxxx # 增加库搜索目录\nclang -lxx # 增加库文件  libxx.后缀\n\n\n\n常用编译选项-Wall : 显示所有常用的编译警告信息。\n-W : 显示更多的常用编译警告，如：变量未使用、一些逻辑错误。\n-Werror : 将警告升级为错误\n-fPIC : 共享库应创建位置无关代码\n-v : 打印编译一个文件的所有步骤\n-D : -D&lt;macroname&gt;=&lt;value&gt; 定义宏\n-U : undef\n@xx : 从文件xx中读取参数\n-std : -std=c++11/c++14/c++17/c90/c89/\n-static -shared\n-ccc-print-phases : 打印编译阶段\n-L$(brew --prefix gperftools)/lib\n\n其他参数\n","slug":"clang-编译链接","date":"2022-11-03T01:02:21.000Z","categories_index":"笔记","tags_index":"clang","author_index":"YiLongDong"},{"id":"436815cb6db7489e3a0d980760c16cd5","title":"CMake Cookbook 第二章: 检测环境","content":"CMake Cookbook 第二章: 检测环境\n\n\n本文是对 cmake cookbook中文翻译的学习笔记记录，建议看原文。\n检测操作系统环境if(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n\tmessage(STATUS \"Configuring on/for Linux\")\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n\tmessage(STATUS \"Configuring on/for macOS\")\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"Windows\")\n\tmessage(STATUS \"Configuring on/for Windows\")\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"AIX\")\n\tmessage(STATUS \"Configuring on/for IBM AIX\")\nelse()\n\tmessage(STATUS \"Configuring on/for ${CMAKE_SYSTEM_NAME}\")\nendif()\n\n\n\n\n\n处理平台和编译器相关代码#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstd::string say_hello() {\n#ifdef IS_WINDOWS\n  return std::string(\"Hello from Windows!\");\n#elif IS_LINUX\n  return std::string(\"Hello from Linux!\");\n#elif IS_MACOS\n  return std::string(\"Hello from macOS!\");\n#else\n  return std::string(\"Hello from an unknown system!\");\n#endif\n  \n#ifdef IS_INTEL_CXX_COMPILER\n  return std::string(\"Hello Intel compiler!\");\n#elif IS_GNU_CXX_COMPILER\n  return std::string(\"Hello GNU compiler!\");\n#elif IS_PGI_CXX_COMPILER\n  return std::string(\"Hello PGI compiler!\");\n#elif IS_XL_CXX_COMPILER\n  return std::string(\"Hello XL compiler!\");\n#else\n  return std::string(\"Hello unknown compiler - have we met before?\");\n#endif\n}\n\nint main() {\n  std::cout &lt;&lt; say_hello() &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"compiler name is \" COMPILER_NAME &lt;&lt; std::endl;\n  return EXIT_SUCCESS;\n}\n\n\n\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\nproject(recipe-02 LANGUAGES CXX)\nadd_executable(hello-world hello-world.cpp)\n# 处理平台相关代码\nif(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n  target_compile_definitions(hello-world PUBLIC \"IS_LINUX\")\nendif()\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n  target_compile_definitions(hello-world PUBLIC \"IS_MACOS\")\nendif()\nif(CMAKE_SYSTEM_NAME STREQUAL \"Windows\")\n  target_compile_definitions(hello-world PUBLIC \"IS_WINDOWS\")\nendif()\n\n# 处理编译器相关代码\ntarget_compile_definitions(hello-world PUBLIC \"COMPILER_NAME=\\\"${CMAKE_CXX_COMPILER_ID}\\\"\")\n\nif(CMAKE_CXX_COMPILER_ID MATCHES Intel)\n  target_compile_definitions(hello-world PUBLIC \"IS_INTEL_CXX_COMPILER\")\nendif()\nif(CMAKE_CXX_COMPILER_ID MATCHES GNU)\n  target_compile_definitions(hello-world PUBLIC \"IS_GNU_CXX_COMPILER\")\nendif()\nif(CMAKE_CXX_COMPILER_ID MATCHES PGI)\n  target_compile_definitions(hello-world PUBLIC \"IS_PGI_CXX_COMPILER\")\nendif()\nif(CMAKE_CXX_COMPILER_ID MATCHES XL)\n  target_compile_definitions(hello-world PUBLIC \"IS_XL_CXX_COMPILER\")\nendif()\n\n\n\n检测处理器体系结构与指令集暂时用不到\n需要可以点击查看\n为Eigen库使能向量化暂时用不到\n需要可以点击查看\n","slug":"CMake-Cookbook-第二章-检测环境","date":"2022-10-31T14:29:40.000Z","categories_index":"笔记","tags_index":"CMake","author_index":"YiLongDong"},{"id":"a98e3c9f33f729f12ec0aac8a3ccd800","title":"CMake Cookbook 第一章：从可执行文件到库","content":"CMake Cookbook 第一章：从可执行文件到库\n\n\n\n本文是对 cmake cookbook中文翻译的学习笔记记录，建议看原文。\nCMake是一个构建系统生成器。将描述构建系统(如：Unix Makefile、Ninja、Visual Studio等)应当如何操作才能编译代码。\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\nproject(recipe-01 LANGUAGES C CXX) # 可以设置语言\n\n切换生成器CMake语言不区分大小写，但是参数区分\nmkdir -p build\ncd build\ncmake -G Ninja .. # -G切换生成器\n# cmake -H. -Bbuild\n# -H.代表在当前目录搜索根CMakeLists.txtx文件，\n# -Bbuild表示在名为build的目录下生成所有文件\ncmake --build . # 编译\n\n静态库与动态库add_library(${libname_static} STATIC xxx.h xxx.cpp)\nadd_library(${libname_shared} SHARED xxx.h xxx.cpp)\ntarget_link_libraries(${exename} ${libname_static})\ntarget_link_libraries(${exename} ${libname_shared})\n\ntarget_sources介绍\ntarget_include_directories\n条件判断\nset(USE_LIBRARY OFF) # 硬编码 \n# 1, ON, YES, true, Y,非0数，为true\n# 0, OFF, NO, false, N, IGNORE, NOTFOUND, 空字符串，为false\n\nmessage(STATUS \"Compile source into a library? ${USE_LIBRARY}\")\nlist(APPEND _sources Message.hpp Message.cpp)\nif(USE_LIBRARY)\n\tadd_library(message ${_sources})\n\tadd_executable(hello-world hello-world.cpp)\n\ttarget_link_libraries(hello-world message)\nelse(USE_LIBRARY)\n\tadd_executable(hello-world hello-world.cpp ${_sources})\nendif(USE_LIBRARY)\n\n局部变量可以在名称前加下划线\ncmake 选项 optioninclude(CMakeDependentOption)\n# cmake可以通过包含模块扩展语法和功能\n# cmake --help-module CMakeDependentOption 可以查看手册\n\noption(USE_LIBRARY \"Compile source into a library\" OFF)\n# 使用方式 option(变量名 帮助字符串 默认值)\n# cmake -H. -Bbuild -D USE_LIBRARY=ON 可以开启选项\n\n# 有依赖关系到选项\ncmake_dependent_option(\n\tMAKE_STATIC_LIBRARY \"Compile sources into a static library\" OFF\n\t\"USE_LIBRARY\" ON\n\t)\n\t\ncmake_dependent_option(\n\tMAKE_SHARED_LIBRARY \"Compile sources into a shared library\" ON\n\t\"USE_LIBRARY\" ON\n\t)\n\n\n\n指定编译器cmake -H. -Bbuild -D CMAKE_CXX_COMPILER=clang++\n# 指定编译器\n\ncmake --system-information information.txt\n# 可用的编译器和编译器标志\n\n\n\n切换构建类型CMake可以配置构建类型，例如：Debug、Release等。配置时，可以为Debug或Release构建设置相关的选项或属性，例如：编译器和链接器标志。控制生成构建系统使用的配置变量是CMAKE_BUILD_TYPE。该变量默认为空，可选值如下：\nDebug, ReleaseRelWithDebInfo：用于构建较少的优化库或可执行文件，包含调试符号。MinSizeRel：用于不增加目标代码大小的优化方式来构建库或可执行文件。\ncmake -H. -Bbuild -D CMAKE_BUILD_TYPE=Debug\n\nif(NOT CMAKE_BUILD_TYPE) # 便于命令行覆盖\n\tset(CMAKE_BUILD_TYPE Release CACHE STRING \"Build type\" FORCE)\nendif()\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\n\n为Release版和Debug版单独创建构建目录会比较方便。\n设置编译选项list(APPEND flags \"-fPIC\" \"-Wall\")\nif(NOT WIN32)\n  list(APPEND flags \"-Wextra\" \"-Wpedantic\")\nendif()\ntarget_compile_options(testlib\n  PRIVATE\n    ${flags}\n  )\n# PRIVATE，编译选项会应用于给定的目标，不会传递给与目标相关的目标\n# INTERFACE，给定的编译选项将只应用于指定目标，并传递给与目标相关的目标。\n# PUBLIC，编译选项将应用于指定目标和使用它的目标。\n\ncmake --build . -- VERBOSE=1\n# 设置VERBOSE可以看到详细的编译参数和过程\n\n\n\nset(COMPILER_FLAGS)\nset(COMPILER_FLAGS_DEBUG)\nset(COMPILER_FLAGS_RELEASE)\n\nif(CMAKE_CXX_COMPILER_ID MATCHES GNU)\n  list(APPEND CXX_FLAGS \"-fno-rtti\" \"-fno-exceptions\")\n  list(APPEND CXX_FLAGS_DEBUG \"-Wsuggest-final-types\" \"-Wsuggest-final-methods\" \"-Wsuggest-override\")\n  list(APPEND CXX_FLAGS_RELEASE \"-O3\" \"-Wno-unused\")\nendif()\n\nif(CMAKE_CXX_COMPILER_ID MATCHES Clang)\n  list(APPEND CXX_FLAGS \"-fno-rtti\" \"-fno-exceptions\" \"-Qunused-arguments\" \"-fcolor-diagnostics\")\n  list(APPEND CXX_FLAGS_DEBUG \"-Wdocumentation\")\n  list(APPEND CXX_FLAGS_RELEASE \"-O3\" \"-Wno-unused\")\nendif()\n\ntarget_compile_option(compute-areas\n  PRIVATE\n    ${CXX_FLAGS}\n    \"$&lt;$&lt;CONFIG:Debug&gt;:${CXX_FLAGS_DEBUG}&gt;\"\n    \"$&lt;$&lt;CONFIG:Release&gt;:${CXX_FLAGS_RELEASE}&gt;\"\n  )\n# 为不同配置使用不同flags\n\n\n\n设置语言标准set_target_properties(animal-farm\n  PROPERTIES\n    CXX_STANDARD 14\n    CXX_EXTENSIONS OFF # 只启用ISO C++标准的编译器标志，而不使用特定编译器的扩展。\n    CXX_STANDARD_REQUIRED ON # 如果这个版本不可用，CMake将停止配置并出现错误\n  )\n\n\n\n循环list(\n  APPEND sources_with_lower_optimization\n    geometry_circle.cpp\n    geometry_rhombus.cpp\n  )\n\nmessage(STATUS \"Setting source properties using IN LISTS syntax:\")\nforeach(_source IN LISTS sources_with_lower_optimization)\n  set_source_files_properties(${_source} PROPERTIES COMPILE_FLAGS -O2)\n  message(STATUS \"Appending -O2 flag for ${_source}\")\nendforeach()\n\nmessage(STATUS \"Querying sources properties using plain syntax:\")\nforeach(_source ${sources_with_lower_optimization})\n  get_source_file_property(_flags ${_source} COMPILE_FLAGS)\n  message(STATUS \"Source ${_source} has the following extra COMPILE_FLAGS: ${_flags}\")\nendforeach()\n\nset_source_files_properties(file PROPERTIES property value) ，它将属性设置为给定文件的传递值。\nget_source_file_property(VAR file property)，检索给定文件所需属性的值，并将其存储在CMakeVAR变量中。\n\n人文/社会网络学分\n\n人文素质活动，线上的文体活动/如何证明参加过迎新晚会等活动\n\n其他毕业要求，例如体质等等\n\n两次SRP创新分应该OK吧\n\n\n","slug":"CMake-Cookbook-第一章-从可执行文件到库","date":"2022-10-31T13:15:36.000Z","categories_index":"笔记","tags_index":"CMake","author_index":"YiLongDong"},{"id":"cee19f16f6880f19e7601a3124300b66","title":"Javascript学习 基础","content":"Javascript基础知识\n\n\n\n\n\njavascript mdn\nJavaScript教程\nECMAScript6学习\n网道\n","slug":"Javascript学习-基础","date":"2022-10-30T15:10:11.000Z","categories_index":"笔记","tags_index":"Javascript","author_index":"YiLongDong"},{"id":"f93b6c858be383138822a089f75a859c","title":"搭建个人博客","content":"博客制作教程：typora图床 + 域名与github部署 + 博客样式\n\n\n搭建个人博客写作工具阿里云 oss 对象存储 + PicGo + Typora =&gt; 自动上传图片的md编辑器\n相信具体步骤很容易就能查到，我就不写了。\nhttps://zhuanlan.zhihu.com/p/344973958\n网站部署阿里云域名与解析 + Github Page + ssh =&gt; 网站部署方式\n相信具体步骤很容易就能查到，我就只写几个注意点。\n/blog/source下新建文件CNAME，文件内容是自己的域名，例如yilongdong.top\n(域名解析A记录也能用，但是还是CNAME更好)\n给github设置了ssh公钥后还需要获取token。第一次上传文件需要登陆，token就是密码。之后就免密了。\nGitHub page开启https。\n\nhttps://blog.51cto.com/u_15064642/2572458\n博客样式Hexo + 闪烁之狐主题 + 手动配置 =&gt; 网站样式\n相信具体步骤很容易就能查到，我就不写了。\nhttp://blinkfox.com\n其他样式\nhttps://hexo.io/themes/\n博客订阅开启RSS后，可以在Fluent阅读器下订阅\n添加订阅源\nxxx/atom.xml\n\n开启提醒规则\n\n设置抓取频率\n\n","slug":"搭建个人博客","date":"2022-10-30T02:54:58.000Z","categories_index":"","tags_index":"教程","author_index":"YiLongDong"}]